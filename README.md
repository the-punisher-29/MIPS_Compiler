# MIPS Compiler Project(Computer Architecture)

## Overview
This project involves the development and successful completion of a simulation of a MIPS processor. The main objectives achieved were:
1. Compiling MIPS assembly code into machine code (binary instructions).
2. Simulating the execution of the machine code using a simulated MIPS datapath, generating control signals, and simulating the ALU and other operations.

### Achievements
- Translated MIPS assembly into machine code using a custom compiler.
- Simulated the execution of basic MIPS instructions, including arithmetic, memory access, and branching.
- Generated control signals and simulated the data flow within an MIPS-like architecture.

---

## Project Structure

The project is implemented in two main C++ files:

1. **`MIPSCompiler.cpp`**: 
   - This file is responsible for reading MIPS assembly instructions and generating binary machine code. 
   - It parses the input assembly file, identifies the type of instruction (R-type, I-type, J-type), and converts it into the standard MIPS binary format.

2. **`MIPSProcessor.cpp`**: 
   - This file simulates the execution of the binary machine code generated by the compiler.
   - It processes the binary instructions to simulate the MIPS datapath, including the ALU, memory access, branching, and register updates.
   - Outputs the state of all registers after execution.

---

## Description of MIPS Processor (Electrical Perspective)
The MIPS processor is a Reduced Instruction Set Computer (RISC) architecture, designed for efficient execution of instructions with a simple and regular instruction set. 

### Key Components:
1. **ALU (Arithmetic Logic Unit):**
   - Performs arithmetic (e.g., addition, subtraction) and logic operations (e.g., AND, OR).
   - Operates based on control signals generated during instruction decode.

2. **Registers:**
   - Includes 32 general-purpose registers (e.g., `$t0`, `$s0`) for storing temporary values and results.
   - Registers are implemented using flip-flops for fast read and write access.

3. **Control Unit:**
   - Decodes instructions and generates control signals to drive the datapath.
   - Signals include ALU operation control, memory read/write enable, and branch decision.

4. **Memory:**
   - Simulates main memory (RAM) for storing data and instructions.
   - Load (`lw`) and store (`sw`) operations are executed by accessing memory via calculated offsets.

5. **Program Counter (PC):**
   - Keeps track of the address of the next instruction to execute.
   - Updated sequentially or modified during branching (`beq`, `j`).

6. **Pipeline (Simulated):**
   - Implements a simplified MIPS pipeline:
     - **Instruction Fetch**: Retrieve the instruction from memory.
     - **Instruction Decode**: Interpret the instruction and generate control signals.
     - **Execution**: Perform ALU operations or calculate memory addresses.
     - **Memory Access**: Read/write memory for `lw`/`sw` instructions.
     - **Write Back**: Store results back into registers.

---

## Usage

### Requirements
- C++ Compiler (e.g., GCC, Clang)
- Text editor or IDE

### Compilation
1. Compile the MIPS Compiler:
   ```bash
   g++ MIPSCompiler.cpp -o MIPSCompiler
   ```
2. Compile the MIPS Processor:
   ```bash
   g++ MIPSProcessor.cpp -o MIPSProcessor
   ```

### Execution
1. **Generate Binary Data:**
   - Provide a MIPS assembly file (e.g., `input.asm`) as input to the compiler.
   - Run the following command:
     ```bash
     ./MIPSCompiler input.asm binary_output.bin
     ```
2. **Simulate Execution:**
   - Use the binary output file as input to the processor simulation:
     ```bash
     ./MIPSProcessor binary_output.bin
     ```
3. **View Output:**
   - The processor simulation outputs the state of all registers after execution.

---

## Example Workflow

### Assembly Input (`input.asm`):
```asm
.data
array: .word 5, 10, 15, 20
.text
main:
    lw $t0, 0(array)
    addi $t1, $t0, 5
    sw $t1, 4(array)
    beq $t1, $t0, end
    j main
end:
    add $t2, $t0, $t1
```

### Binary Output (`binary_output.bin`):
```
100011 00000 01000 00000 00000 000000
001000 01000 01001 00000 00000 000101
101011 00000 01001 00000 00000 000100
000100 01001 01000 00000 00000 000011
000010 00000 00000 00000 00000 000001
000000 01000 01001 01010 00000 100000
```

### Processor Output:
```
Registers after execution:
$t0: 5
$t1: 10
$t2: 15
...
```

---

## Testing and Results
We tested the simulator with 5 MIPS programs, including:
1. Basic arithmetic operations.
2. Memory access and updates.
3. Conditional branching.
4. Complex nested loops.
5. Array manipulations.

### Results
- All test cases executed successfully.
- The register states and memory outputs matched expected values.

---

## Conclusion
This project successfully demonstrates the implementation of a MIPS Compiler and Processor simulation. By combining binary compilation and datapath simulation, it provides a comprehensive understanding of MIPS architecture and its operations.

---

## Acknowledgments
This project is part of the CSL3020 course at IIT Jodhpur. It was developed to enhance understanding of MIPS architecture and its practical simulation.

